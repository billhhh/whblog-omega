---
layout: post
title: sizeof小览
category: c++
comments: true
---

[本篇csdn博客链接](http://blog.csdn.net/scythe666/article/details/47012347)

##一、文章来由---一道面试题迁出的探究
我发现我已经形成一种习惯写来由了，以后看博客的时候可以让我回忆起为什么出现这个问题，我用什么方法解决的，既然形成习惯就让这个习惯保持下去吧。今天实验室师姐在看书，一处不解，是关于sizeof的，大家讨论此问题后，我一向信服做了才知道答案，于是有了这篇文章。但是只能叫小览，因为不可能总结完sizeof的用法，欢迎补充和讨论。

##二、从这道题目说起
我直接将问题的关键部分提出来：
```c++
string strArr1[] = { "Trend", "Micro", "Soft" };
cout << "sizeof(strArr1) == " << sizeof(strArr1) << endl;
```
请问输出多少，书上的答案这样写道：

> 而字符串strArr1是由3段构成的，所 以sizeof(strArr1)大小是12。
> 首先要明确sizeof不是函数，也不是一元运算符，它是个类似宏定义的特殊关键字，**特别是sizeof(string)=4**。 

这个不去试是不知道的，因为编译器那么多，编译器做什么事情不去试怎么可能知道

果然，在vs2013 release模式下结果是

> sizeof(string) == 24
> sizeof(strArr1) == 72

debug模式

> sizeof(string) == 28
> sizeof(strArr1) == 84

也是3倍关系，因为这是一个string数组，里面有三个string对象

那么为什么string有不同的结果？

> 查阅了相关资料得出结论：我们知道char*肯定是4字节，string里面可能不止包含一个char*那么简单，还包含有长度信息等其他信息，string的实现在各库中可能有所不同，但是在同一库中相同一点是，无论你的string里放多长的字符串，它的sizeof()都是固定的，字符串所占的空间是从堆中动态分配的，与sizeof()无关。

   
      sizeof(string)=4可能是最典型的实现之一，不过也有sizeof()为12、32字节的库实现。 但是VC6.0测试后sizeof(string)=16.还是跟编译器有关


为了完全测试一些东西，我测试越写越多，然后我来了威力加强版，见代码：
```c++
#include<iostream>

using namespace std;

int main()
{
	char p[] = { 'a', 'b', 'c', 'a', 'b', 'c' };
	char *p1 = "abcabc";
	char p2[] = "abcabc";
	char p3[][2] = { { 'a', 'b' }, { 'c', 'a' }, { 'b', 'c' } };
	printf("p == %s\n", p);
	cout << p << endl;
	cout << "sizeof(p) == " << sizeof(p) << endl;
	cout << "sizeof(p1) == " << sizeof(p1) << endl;
	cout << "sizeof(p2) == " << sizeof(p2) << endl;
	cout << "sizeof(p3) == " << sizeof(p3) << endl;

	cout<<"sizeof(string) == " << sizeof(string) << endl;

	string strArr1[] = { "Trend", "Micro", "Soft" };
	cout << "sizeof(strArr1) == " << sizeof(strArr1) << endl;

	int a = 0;
	cout <<"sizeof(a = 3) == " << sizeof(a = 3) << endl;
	cout << "a == " << a << endl;

	cout << "sizeof(999999) == " << sizeof(999999) << endl;
	cout << "sizeof(9999999999999999999) == " << sizeof(9999999999999999999) << endl;
	cout << "sizeof(9 / 5) == " << sizeof(9 / 5) << endl;
	cout << "sizeof((double)9 / 5) == " << sizeof((double)9 / 5) << endl;

	return 0;
}
```

运行结果如图所示：
![这里写图片描述](http://img.blog.csdn.net/20150722233014415)

我来一一解释我的这些测试在做什么：
（1）首先p的这种初始化方式，在末尾不会加'\0'，所以 sizeof(p) == 6；而且一个有趣的问题是**printf和cout直接输出p是不同的**，printf是要碰到'\0'结束，我也看了printf和cout的汇编代码，但是没有细究，之后又空详细研究一下
（2）p1和p2的sizeof不同，因为一个是指针，一个是字符数组，指针在Win32编译环境下的sizeof都是4，因为是4字节的地址，32bits可寻址空间
（3）p3是另一个有趣的问题，**p3不能写成p3[3][]来初始化**，因为这样初始化要保证二维数组每一行的个数相同，也就是不能出现“参差不齐”的情况，那种情况要动态分配
（4）这是一个陷阱
```c++
int a = 0;
cout<<sizeof(a=3)<<endl;
cout<<a<<endl;
```
输出为什么是4，0  而不是期望中的4，3？？？就在于sizeof在编译阶段处理的特性。由于sizeof不能被编译成机器码，所以sizeof作用范围内，也就是()里面的内容**不能被编译**，而是被替换成类型。=操作符返回左操作数的类型，所以a=3相当于int，而代码也被替换为：

```c++
cout<<4<<endl;
cout<<a<<endl;
```

所以，sizeof是不可能支持链式表达式的，这也是和一元操作符不一样的地方。

> 不要把sizeof当成函数，也不要看作一元操作符，把他当成一个特殊的编译预处理。

（5）这样的原因是999999是一个编译器int型可以搞定的数，所以按int来处理，太大的数不能用int搞定，但是8个字节一定可以搞定的

> sizeof(999999) == 4
> sizeof(9999999999999999999) == 8

（6）最后是看了（9 / 5）编译器是作为int看待的，强制转换后才是double


##三、sizeof 能总结多少是多少
sizeof博大精深，即使看了很多资料，一口气总结完也是不可能了，总结常用的就好。

###1、什么是sizeof

    首先看一下sizeof在msdn上的定义：

    The sizeof keyword gives the amount of storage, in bytes, associated with a variable or a type (including aggregate types). This keyword returns a value of type size_t.

    看到return这个字眼，是不是想到了函数？错了，sizeof不是一个函数，你见过给一个函数传参数，而不加括号的吗？sizeof可以，所以sizeof不是函数。网上有人说sizeof是一元操作符，但是我并不这么认为，因为sizeof更像一个特殊的宏，它是在编译阶段求值的。举个例子：

```c++
cout<<sizeof(int)<<endl; // 32位机上int长度为4
cout<<sizeof(1==2)<<endl; // == 操作符返回bool类型，相当于 cout<<sizeof(bool)<<endl;
```

    在编译阶段已经被翻译为：

```c++
cout<<4<<endl;
cout<<1<<endl;
```

###2、语法

sizeof有三种语法形式，如下：

1) sizeof( object ); // sizeof( 对象 );
2) sizeof( type_name ); // sizeof( 类型 );
3) sizeof object; // sizeof 对象;
所以，

int i;
sizeof( i ); // ok
sizeof i; // ok
sizeof( int ); // ok
sizeof int; // error
既然写法1可以完全代替写法3，为求形式统一以及减少我们大脑的负担，第3种写法，忘掉它吧！

实际上，sizeof计算对象的大小也是转换成对对象类型的计算，也就是说，同种类型的不同对象其sizeof值都是一致的。这里，对象可以进一步延伸至表达式，即sizeof可以对一个表达式求值，编译器根据表达式的最终结果类型来确定大小，一般不会对表达式进行计算。如：

sizeof( 2 ); // 2的类型为int，所以等价于 sizeof( int );
sizeof( 2 + 3.14 ); // 3.14的类型为double，2也会被提升成double类型，所以等价于 sizeof( double );

###3、函数的sizeof
函数类型

    考虑下面的问题：
```c++
int f1(){return 0;};
double f2(){return 0.0;}
void f3(){}

cout<<sizeof(f1())<<endl; // f1()返回值为int，因此被认为是int
cout<<sizeof(f2())<<endl; // f2()返回值为double，因此被认为是double
cout<<sizeof(f3())<<endl; // 错误！无法对void类型使用sizeof
cout<<sizeof(f1)<<endl;   // 错误！无法对函数指针使用sizeof   
cout<<sizeof*f2<<endl;   // *f2，和f2()等价，因为可以看作object，所以括号不是必要的。被认为是double
```
>**结论：对函数使用sizeof，在编译阶段会被函数返回值的类型取代**


###4、数组的sizeof

```c++
char a[] = "abcdef";
int b[20] = {3, 4};
char c[2][3] = {"aa", "bb"};

cout<<sizeof(a)<<endl; // 7
cout<<sizeof(b)<<endl; // 20*4=80
cout<<sizeof(c)<<endl; // 6
```
数组a的大小在定义时未指定，编译时给它分配的空间是按照初始化的值确定的，也就是7。c是多维数组，占用的空间大小是各维数的乘积，也就是6。可以看出，数组的大小就是他在编译时被分配的空间，也就是各维数的乘积*数组元素的大小。

> **结论：数组的大小是各维数的乘积*数组元素的大小。**

这里有一个陷阱：
```c++
int *d = new int[10];

cout<<sizeof(d)<<endl; // 4
```
d是我们常说的动态数组，但是他实质上还是一个指针，所以sizeof(d)的值是4。
再考虑下面的问题：
```c++
double* (*a)[3][6];
cout<<sizeof(a)<<endl;   // 4
cout<<sizeof(*a)<<endl;   // 72
cout<<sizeof(**a)<<endl; // 24
cout<<sizeof(***a)<<endl; // 4
cout<<sizeof(****a)<<endl; // 8
```
a是一个很奇怪的定义，他表示一个指向 double*[3][6]类型数组的指针。既然是指针，所以sizeof(a)就是4。

    既然a是执行double*[3][6]类型的指针，*a就表示一个double*[3][6]的多维数组类型，因此sizeof(*a)=3*6*sizeof(double*)=72。同样的，**a表示一个double*[6]类型的数组，所以sizeof(**a)=6*sizeof(double*)=24。***a就表示其中的一个元素，也就是double*了，所以sizeof(***a)=4。至于****a，就是一个double了，所以sizeof(****a)=sizeof(double)=8。

差不多也要结束了，如果更进一步了解，需要查阅更多的资料~~~

---END---

---
####参考文献
[1] http://blog.csdn.net/freefalcon/article/details/54839
[2] http://www.cnblogs.com/wanghetao/archive/2012/04/04/2431760.html
