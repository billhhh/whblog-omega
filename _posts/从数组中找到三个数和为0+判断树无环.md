# 一、第一题：从一个数组中找到三个数和为0的所有组合

第一思路是，直接暴力！但是这样是O（n^3）的时间复杂度

于是想到改进版本：将数组分为正数+负数集合，一定先是从正数和负数集当中各挑出一个（否则不可能和为0），然后计算sum，接着看这个sum的负数是不是在所有数组中。

详见代码：
```c++
#include <iostream>
#include <stdio.h>
#include <cstring>
#include <vector>
#include <cmath>
#include <algorithm>
#include <set>
#include <cassert>
#include <time.h>
#include <queue>
#include <map>
#include <stack>
#include <bitset>
#include <string>
#include <sstream>
#define INF 0x3f3f3f3f

#define PRINT(x) cout<<x<<endl;

using namespace std;

template <class Type>
Type stringToNum(const string& str)
{
	istringstream iss(str);
	Type num;
	iss >> num;
	return num;    
}

//======================================================

int find_tri(int* A, int num, int cnt) {

	for (int i = 0; i < cnt; i++)
		if (A[i] == num)
			return 1;

	return 0;
}

int main()
{
	//freopen("input.txt","r",stdin);

	int k=10;
	int arr[10] = {1,-2,3,-1,2,-3,4,5,-5,6};

	int neg_cnt = 0;
	int pos_cnt = 0;
	int arr_negtive[10];
	int arr_positive[10];
	for (int i = 0; i < k; i++) {
		if (arr[i] < 0)
			arr_negtive[neg_cnt++] = arr[i];
		else
			arr_positive[pos_cnt++] = arr[i];
	}

	// for triplets
	int tri_count = 0;
	int res;
	for (int i = 0; i < pos_cnt; i++)
		for (int j = 0; j < neg_cnt; j++) {
			int sum = arr_positive[i] + arr_negtive[j];
			if (sum < 0)
				res = find_tri(arr_positive, -sum, pos_cnt);
			else
				res = find_tri(arr_negtive, -sum, neg_cnt);

			if (res == 1 && -sum != arr_positive[i] && -sum != arr_negtive[j]) {
				tri_count++;
				cout << arr_positive[i] << " " << arr_negtive[j] << " " << -sum << endl;
			}
		}

	cout << tri_count << endl;
	return 0;
}
```

但是Jianming老师点出，这里仍然是O（n^3）的时间复杂度。。。因为在两层循环中还嵌套了一个循环。。。

于是又想出一个变通方法，在search -sum值的时候，可以用二分查找，这样就需要先排序，所以复杂度就停留在O（n^2*logn）

之后在网上看到可以在O（n^2）解决，很妙的解法
http://blog.csdn.net/u013309870/article/details/63704598

> 算法思想： 
现将数组排序，i 指向数组的开始，j 指向i 的后一位，k 指向数组最后，如果 
arr[i]+arr[j]+arr[k]==0，j++,k–; 
否则如果 
arr[i]+arr[j]+arr[k]>0 
k–; 
否则 
arr[i]+arr[j]+arr[k]<0 
i++;

```java
public static  void findTriplets(int arr[], int n){
        Arrays.sort(arr);//把数组先从小到大排序
        for(int i=0;i<n-2;i++)
        {
            int j=i+1;
            int k=n-1;
            while(k>j)
            {
                if(arr[i]+arr[j]+arr[k]==0)
                {//如果相加为0就输出
                    System.out.println(arr[i]+" "+arr[j]+" "+arr[k]);
                    j++;
                    k--;
                }
                else if(arr[i]+arr[j]+arr[k]>0){
                    k--;
                    //如果相加大于0时k--
                }
                else {
                    j++;
                    //相加小于0时j++
                }
            }
        }
    }
```

# 二、判断树中有没有环

因为是无向图，所以不能用拓扑排序，只能用深搜

总的来说，这题求解还算顺利，但是还是花了太多时间，毕竟平时还是太少敲这些算法了，写成模板以后就不怎么去盲敲了。。

![这里写图片描述](http://img.blog.csdn.net/20171126175635141?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvU2N5dGhlNjY2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

按道理说，这里应该有4个环，但是程序肯定只算小环的，因为：

> 1、首先A入栈
> 2、然后A出栈，B、C入栈
> 3、然后C出栈，B入栈发现已存在，发现一个loop，E入栈
> 4、E出栈，B入栈又发现已存在，发现2个loop，F入栈，G入栈
> ...
> 后面还会发现一个loop

所以是一共3个


```c++
#include <iostream>
#include <stdio.h>
#include <cstring>
#include <vector>
#include <cmath>
#include <algorithm>
#include <set>
#include <cassert>
#include <time.h>
#include <queue>
#include <map>
#include <stack>
#include <bitset>
#include <string>
#include <sstream>
#define INF 0x3f3f3f3f

#define PRINT(x) cout<<x<<endl;

using namespace std;

template <class Type>
Type stringToNum(const string& str)
{
	istringstream iss(str);
	Type num;
	iss >> num;
	return num;    
}

//======================================================

int graph_map[8][8];
int visit[8];
int inStack[8];
int loop_cnt = 0;

void DFS(int node) {

	stack<int > s;
	
	//init
	s.push(node);
	inStack[node] = 1;
	while (!s.empty()) {
		int process_node = s.top();
		s.pop();
		inStack[process_node] = 0;
		visit[process_node] = 1;

		//push the children of process_node into s
		for (int i = 1; i <= 7; i++) {
			if (graph_map[process_node][i] == 1 && !visit[i]) {
				//if in the stack already, so there is a loop
				if (inStack[i]) {
					loop_cnt++;
					continue;
				}

				//or push it into the stack
				s.push(i);
				inStack[i] = 1;

			}
		}

	}
}

int main()
{
	//freopen("input.txt","r",stdin);
	graph_map[1][2] = 1;
	graph_map[2][1] = 1;

	graph_map[1][3] = 1;
	graph_map[3][1] = 1;

	graph_map[2][4] = 1;
	graph_map[4][2] = 1;

	graph_map[2][5] = 1;
	graph_map[5][2] = 1;

	graph_map[5][6] = 1;
	graph_map[6][5] = 1;

	graph_map[6][7] = 1;
	graph_map[7][6] = 1;

	graph_map[5][7] = 1;
	graph_map[7][5] = 1;

	graph_map[5][3] = 1;
	graph_map[3][5] = 1;

	graph_map[2][3] = 1;
	graph_map[3][2] = 1;

	DFS(1);

	cout << loop_cnt << endl;

	return 0;
}
```

# 三、总结

Jianming老师说的对：

1、编程能力还需要进一步加强（第一题不该卡这么久）
2、需要更有逻辑编程，程序要更neat。我平时编程逻辑性不错，今天可能是因为比较紧张导致的

反思：平时都是写工程代码，或者是已经有想法了去实现，但是今天，尤其是第一题没有想到最优解，影响了写代码，以后应该多注意这些基本功，平时没事的时候还是需要常拿出来晒晒

> 这说明，还是要思路清晰，才能着手开始写代码