---
layout: post
title: 关于左移和右移
category: c++
comments: true
---

##一、文章来由

项目需要将一个int拆开成高16位和低15位存不同的id，形成一个新的id，所以~~~


##二、算术移位和逻辑移位

> 算术移位---有符号数的倍增、减半；
逻辑移位---无符号数的倍增、减半.

比如一个有符号位的8位二进制数11001101，逻辑右移就不管符号位，如果移一位就变成01100110。算术右移要管符号位，右移一位变成10100110。

**左移**
逻辑左移=算数左移，右边统一添0。
**右移**
（1）逻辑右移，左边统一添0（无符号）
（2）算数右移，左边添加的数和符号有关（有符号）

e.g:1010101010，其中[]位是添加的数字  
逻辑左移一位：010101010[0]  
算数左移一位：010101010[0]  
逻辑右移一位：[0]101010101  
算数右移一位：[1]101010101

##三、一个有说服力的例子

```c++
#include <stdlib.h> 
#include <stdio.h>
#include <iostream>

using namespace std;

void showInBinary(int number) {

	char string[100];

	itoa(number, string, 2); 
	printf("integer = %3d string = %s\n", number, string);
}

int main() 
{ 
	int number = -5;
	cout<<"左移之前"<<endl;
	showInBinary(number);

	number = number<<29;

	cout<<"左移之后"<<endl;
	showInBinary(number);

	return 0; 
}
```

运行结果：
![这里写图片描述](http://img.blog.csdn.net/20151205002944940)

可见是将 -5 左移 29 位后变成正数了~~~

同时这个又扯出来一个问题：什么负数左移1位变成正数？

请看下一篇文章~~~




