---
layout: post
title: 补码转原码（算术左移一位负变正）
category: c++
comments: true
---

##一、文章来由

还是上一篇关于移位的问题，那么什么 int 型数只算术左移一位就可以从负数变成正数？？？

##二、又谈补码

很早之前写过一篇关于补码的文章，但是长时间不看又差不多忘记了，翻出来看发现写的挺烂的，有点没说明白，所以希望这里能说明白~~

关于补码，我们知道：

> 在计算机中，一切的一切都是用补码存储

打一个比喻，东西在计算机中是用各种编码存储，不论是字符还是指针（指针也是存储的数据），都是用补码存储。我们写的代码相当于是一个外文的说明书，而编译器是翻译器，将我们的说明书翻译告诉机器如何<font color="red">解读</font>那些存储的信息。

比如同样一个 128，用char解读会出现神奇的效果（详见下篇），但是用int解读还是128！！

> 代码告诉机器如何解读存储的数据

##三、找出这个数

回到正题，那么什么 int 型数只算术左移一位就可以从负数变成正数？ 这个数的从左向右数的第二位必然为0，可以是 10111...1（30个1）。

那么这个数究竟是多少呢？

有一个补码转原码的计算方式是，第一位是符号位
如：1000 = -8,1001 = -8 + 1 = -7, 1011 = -8 + 2 + 1 = -5

即
-2^32+0*2^31+1*2^30+...+1*2^0
= -2^31+2^30-1
=-1073741825

```c++
#include <stdlib.h> 
#include <stdio.h>
#include <iostream>

using namespace std;

void showInBinary(int number) {

	char string[100];

	itoa(number, string, 2); 
	printf("integer = %3d string = %s\n", number, string);
}

int main() 
{ 
	int number = -1073741825;
	cout<<"左移之前"<<endl;
	showInBinary(number);

	number = number<<1;

	cout<<"左移之后"<<endl;
	showInBinary(number);

	return 0; 
}
```

运行结果：
![这里写图片描述](http://img.blog.csdn.net/20151205011250787)

关于这个公式：
![这里写图片描述](http://img.blog.csdn.net/20151205011823156)









