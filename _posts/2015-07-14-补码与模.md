---
layout: post
title: 补码与模
category: c++
comments: true
---

##一、本篇来由
昨天进行了反码、补码那些和浮点数的研究，但是还有一些问题遗漏，晚上跟寝室众基友讨论了，反而提出来一个很有意思的问题，于是有了本篇~~我们并不知道为什么有补码这个东西，只知道在计算机中广泛用补码存储，不知道为什么叫“补”码。

##二、模

>“模”是指一个计量系统的计数范围。如时钟等。计算机也可以看成一个计量机器，它也有一个计量范  围，即都存在一个“模”。

例如： 
时钟的计量范围是0～11，模=12。 

表示n位的计算机计量范围是0～2(n)-1，模=2（n）。【注：n表示指数】 
**“模”实质上是计量器产生“溢出”的量**，它的值在计量器上表示不出来，计量器上只能表示出模的 
余数。任何有模的计量器，均可化减法为加法运算。

例如： 假设当前时针指向10点，而准确时间是6点，调整时间可有以下两种拨法： 
一种是倒拨4小时，即：10-4=6 
另一种是顺拨8小时：10+8=12+6=6 
在以12模的系统中，**加8和减4效果是一样的**，因此凡是减4运算，都可以用加8来代替。
***对“模”而言，8和4互为补数。***实际上以12模的系统中，11和1，10和2，9和3，7和5，6和6都有这个特性。共同的特点是两者相加等于模。 

这样就很清晰了，甚至这里的“模”跟我们学习除法的模和计算机中的mod都扯上了关系~~

##三、补码原理
刚刚提到了模的概念，现在看看计算机补码和模的关系。

对于计算机，其概念和方法完全一样。n位计算机，设n=8， 所能表示的最大数是11111111，若再 
加1称为100000000(9位)，但因只有8位，最高位1自然丢失。又回了00000000，所以8位二进制系统的 
模为2(8)。 在这样的系统中减法问题也可以化成加法问题，只需把减数用相应的补数表示就可以 
了。

> **把补数用到计算机对数的处理上，就是补码。**

另外两个概念 
一的补码(one's complement) 指的是正数=原码,负数=反码。
而二的补码(two's complement) 指的就是通常所指的补码。 

**附：**补码的代数解释 
任何一个数a都可以被表示为：

> -a=2^(n-1)-2^(n-1)-a;

假设a为正数，那么-a就是负数。而根据二进制转十进制数的方法，我们可以把a表示为：

> a = k0*2^0 + k1*2^1 + k2*2^2 +……+ k(n-2)*2^(n-2)

这里k0,k1,k2,k(n-2)是1或者0，而且这里设a的二进制位数为n位，即其模为2^(n-1)，而2^(n-1)其二项展开是:

> 1+2^0+2^1+2^2+……+2^(n-2)

，而将式子`-a=2^(n-1)-2^(n-1)-a`中的，`2^(n-1)-a`代入

> a=k0*2^0+k1*2^1+k2*2^2+……+k(n-2)*2^(n-2)

和

> 2^(n-1)=1+2^0+2^1+2^2+……+2^(n-2)

，得到了

> 2^(n-1)-a ＝ (1- k(n-2))*2^(n-2) + (1- k(n-3))*2^(n-3) +……+ (1- k2)*2^2 + (1- k1)*2^1 + (1- k0)*2^0 +1

**这步转化正说明了取反再加1的规则的代数原理所在。**

***原理：***
因为这里k0,k1,k2,k3……不是0就是1，所以1－k0,1-k1,1-k2的运算就是二进制下的取反，而为什么要加1，追溯起来就是2^(n-1)的二项展开式最后还有一项1的缘故。而-a=2^(n-1)-2^(n-1)-a中，还有-2^(n-1)这项未解释，这项就是补码里首位的1，首位1在转化为十进制时要乘上2^(n-1)，这正是n位二进制的模。


##四、补码与模
绕了这么一圈，终于回来了，万变不离其宗，总要有一个汇聚的时候。看看补码与模到底有什么关系
我们再来看一下刚刚推导公式：
> 2^(n-1)-a ＝ (1- k(n-2))*2^(n-2) + (1- k(n-3))*2^(n-3) +……+ (1- k2)*2^2 + (1- k1)*2^1 + (1- k0)*2^0 +1

其实意思都在里面了，
***总结：***
（1）左边的2^(n-1)就是二进制的“模”，如：8位二进制数，模为2^7=128
（2）左边的 a 是一个数的源码
（3）**右边所有的**就是 **a 的补码**（取反+1）

这里说明了：一个数（负数）的

> **模 = 原码 + 补码**

**例：**
a[原] = -16D = -001 0000B = 1001 0000[计]
a[反] = 1110 1111
a[补] = 1111 0000

反过来看，去掉符号位 

> 模 = a[原] + a[补]，即：128D = 001 0000 + 111 0000

因为对于一个数，计算机中补码是唯一的，所以可以用补码表示一个数
而且这里还有一个问题，就是可以用-0来表示-128，因为-0和-128互为补码

-----END-----

[本篇csdn博客链接](http://blog.csdn.net/Scythe666/article/details/46872391)
