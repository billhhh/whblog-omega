---
layout: post
title: 工厂模式与抽象工厂模式小览（二）
category: 软件架构
comments: true
---

[本篇csdn博客链接](http://blog.csdn.net/scythe666/article/details/48577511)

##一、文章来由
就等啦~~还记得[工厂模式与抽象工厂模式小览（一）](http://blog.csdn.net/Scythe666/article/details/47304985)第一部吗？我们在第一部中，分别详细的描述了（1）简单工厂（2）工厂模式（3）抽象工厂模式，但是并没有描述他们之间的关系，也没有比较工厂模式和抽象工厂模式，这对难舍难分的好基友之间的异同点，这些工作我们在第二部中完成~

##二、工厂模式和简单工厂

	   话说十年前，有一个暴发户，他家有三辆汽车——Benz奔驰、Bmw宝马、Audi奥迪，还雇了司机为他开车。不过，暴发户坐车时总是怪怪的：上Benz车后跟司机说“开奔驰车！”，坐上Bmw后他说“开宝马车！”，坐上Audi说“开奥迪车！”。你一定说：这人有病！直接说开车不就行了？！

而当把这个暴发户的行为放到我们程序设计中来时，会发现这是一个普遍存在的现象。根据上一部的内容，我们知道，这种有病的现象在OO（面向对象）语言中可以避免了，那就是采用：工厂模式。

> 工厂模式主要是为创建对象提供过渡接口，以便将创建对象的具体过程屏蔽隔离起来，达到提高灵活性的目的。

**与简单工厂的异同**

> 工厂方法模式去掉了简单工厂模式中工厂方法的静态属性，使得它可以被子类继承。这样在简单工厂模式里集中在工厂方法上的压力可以由工厂方法模式里不同的工厂子类来分担。

**工厂模式的组成：**

> 1) 抽象工厂角色： 这是工厂方法模式的核心，它与应用程序无关。是具体工厂角色必须实现的接口或者必须继承的父类。在java中它由抽象类或者接口来实现。
 
> 2) 具体工厂角色：它含有和具体业务逻辑有关的代码。由应用程序调用以创建对应的具体产品的对象。
 
> 3) 抽象产品角色：它是具体产品继承的父类或者是实现的接口。在java中一般有抽象类或者接口来实现。
 
> 4) 具体产品角色：具体工厂角色所创建的对象就是此角色的实例。在java中由具体的类来实现。

类图如下：

![这里写图片描述](http://img.blog.csdn.net/20150919190450153)

可见，工厂方法的 **产品类** 和 **创建类** 是在同一层级上。

> 因为如果使用简单工厂模式，在实际应用中，很可能产品是一个多层次的树状结构。由于简单工厂模式中**只有一个工厂类**来对应这些产品，所以这可能会把我们的上帝累坏了，也累坏了我们这些程序员:(
       
于是工厂方法模式作为救世主出现了。 

>工厂方法模式使用继承自抽象工厂角色的多个子类来代替简单工厂模式中的“上帝类”。正如上面所说，这样便分担了对象承受的压力；而且这样使得结构变得灵活起来——当有新的产品（即暴发户的汽车）产生时，只要按照抽象产品角色、抽象工厂角色提供的合同来生成，那么就可以被客户使用，而不必去修改任何已有的代码。可以看出工厂角色的结构也是符合开闭原则的！

话说暴发户生意越做越大，自己的爱车也越来越多。这可苦了那位司机师傅了，什么车它都要记得，维护，都要经过他来使用！于是暴发户同情他说：看你跟我这么多年的份上，以后你不用这么辛苦了，我给你分配几个人手，你只管管好他们就行了！于是，工厂方法模式的管理出现了。代码如下：

```c++
//抽象产品角色，具体产品角色与简单工厂模式类似，只是变得复杂了些，这里略。
//抽象工厂角色
public interface Driver{
       public Car driverCar();
}
public class BenzDriver implements Driver{
       public Car driverCar(){
              return new Benz();
       }
}
public class BmwDriver implements Driver{
       public Car driverCar()   {
 
return new Bmw(); 
       }
}
 
//应该和具体产品形成对应关系...
//有请暴发户先生
 public class Magnate
 {
       public static void main(String[] args)
       {
              try{ 
                     Driver driver = new BenzDriver();
                     Car car = driver.driverCar();
                     car.drive();
              }
       
       ……
 }
```
> 可以看出工厂方法的加入，使得对象的数量成倍增长。当产品种类非常多时，会出现 **大量的与之对应的工厂对象** ，这不是我们所希望的。因为如果不能避免这种情况，可以考虑使用 **简单工厂模式与工厂方法模式相结合** 的方式来减少工厂类：即对于产品树上类似的种类（一般是树的叶子中互为兄弟的）使用简单工厂模式来实现。

工厂方法模式仿佛已经很完美的对对象的创建进行了包装，使得客户程序中仅仅处理抽象产品角色提供的接口。那我们是否一定要在代码中遍布工厂呢？大可不必。也许在下面情况下你可以考虑使用工厂方法模式：
 
> 1)        当客户程序不需要知道要使用对象的创建过程。
 
> 2)        客户程序使用的对象存在变动的可能，或者根本就不知道使用哪一个具体的对象。 

**简单工厂模式与工厂模式**

> 简单工厂模式与工厂方法模式真正的避免了代码的改动了？没有。在简单工厂模式中，新产品的加入要修改工厂角色中的判断语句；而在工厂方法模式中，要么将判断逻辑留在抽象工厂角色中，要么在客户程序中将具体工厂角色写死（就象上面的例子一样）。而且产品对象创建条件的改变必然会引起工厂角色的修改。

面对这种情况，Java的反射机制与配置文件的巧妙结合突破了限制——这在Spring中完美的体现了出来。

##三、工厂模式和抽象工厂模式

先来认识下什么是产品族： 位于不同产品等级结构中，功能相关联的产品组成的家族。还是让我们用一个例子来形象地说明一下吧。

![这里写图片描述](http://img.blog.csdn.net/20150919192047551)

图中的BmwCar和BenzCar就是两个产品树（产品层次结构）；而如图所示的BenzSportsCar和BmwSportsCar就是一个产品族。他们都可以放到跑车家族中，因此功能有所关联。同理BmwBussinessCar和BenzSportsCar也是一个产品族。

> 可以说，抽象工厂模式和工厂方法模式的区别就在于需要创建对象的复杂程度上。而且抽象工厂模式是三个里面最为抽象、最具一般性的。

抽象工厂模式的作用：

> 抽象工厂模式的用意为：给客户端提供一个接口，可以创建多个产品族中的产品对象~~

而且使用抽象工厂模式还要满足如下条件：

> 1)        抽象工厂角色： 这是工厂方法模式的核心，它与应用程序无关。是具体工厂角色必须实现的接口或者必须继承的父类。在java中它由抽象类或者接口来实现。
 
> 2)        具体工厂角色：它含有和具体业务逻辑有关的代码。由应用程序调用以创建对应的具体产品的对象。在java中它由具体的类来实现。
 
> 3)        抽象产品角色：它是具体产品继承的父类或者是实现的接口。在java中一般有抽象类或者接口来实现。
 
> 4)        具体产品角色：具体工厂角色所创建的对象就是此角色的实例。在java中由具体的类来实现。

类图如下：

![这里写图片描述](http://img.blog.csdn.net/20150919192450541)

可以这么说，工厂方法模式是一种 **极端情况的抽象工厂模式** ，而抽象工厂模式可以看成是工厂方法模式的一种推广。

>（1）其实工厂方法模式是用来创建一个产品的等级结构的，而抽象工厂模式是用来创建多个产品的等级结构的。工厂方法创建一般只有一个方法，创建一种产品。抽象工厂一般有多个方法，创建一系列产品。

>（2）工厂方法模式只有一个抽象产品类，而抽象工厂模式有多个。工厂方法模式的具体工厂类只能创建一个具体产品类的实例，而抽象工厂模式可以创建多个。 

简而言之~~

**工厂方法模式：**

（1）一个抽象产品类，可以派生出多个具体产品类。   
（2）一个抽象工厂类，可以派生出多个具体工厂类。   
（3）每个具体工厂类只能创建一个具体产品类的实例。   

**抽象工厂模式：**

（1）多个抽象产品类，每个抽象产品类可以派生出多个具体产品类。   
（2）一个抽象工厂类，可以派生出多个具体工厂类。   
（3）每个具体工厂类可以创建多个具体产品类的实例。 

##四、简单工厂、工厂模式和抽象工厂模式

现在三兄弟一起上了。。。

###4.1 简单工厂

> 简单工厂模式的工厂类一般是使用静态方法，通过接收的参数的不同来返回不同的对象实例。

不修改代码的话，是无法扩展的。

![这里写图片描述](http://img.blog.csdn.net/20150919193307060)

###4.2 工厂模式

> 工厂方法是针对每一种产品提供一个工厂类。通过不同的工厂实例来创建不同的产品实例。

在同一等级结构中，支持增加任意产品。

![这里写图片描述](http://img.blog.csdn.net/20150919193408739)

###4.3 抽象工厂模式

> 抽象工厂是应对产品族概念的。比如说，每个汽车公司可能要同时生产轿车，货车，客车，那么每一个工厂都要有创建轿车，货车和客车的方法。

应对产品族概念而生，增加新的产品线很容易，但是无法增加新的产品。

![这里写图片描述](http://img.blog.csdn.net/20150919193500391)

###4.4 特性总结

> （1）工厂模式中，重要的是工厂类，而不是产品类。产品类可以是多种形式，多层继承或者是单个类都是可以的。但要明确的，工厂模式的接口只会返回一种类型的实例，这是在设计产品类的时候需要注意的，最好是有父类或者共同实现的接口。

> （2）使用工厂模式，返回的实例一定是工厂创建的，而不是从其他对象中获取的。

> （3）工厂模式返回的实例可以不是新创建的，返回由工厂创建好的实例也是可以的。

###4.5 区别

> （1）简单工厂 ： 用来生产同一等级结构中的任意产品。（对于增加新的产品，无能为力）

> （2）工厂方法 ：用来生产同一等级结构中的固定产品。（支持增加任意产品）
   
> （3）抽象工厂 ：用来生产不同产品族的全部产品。（对于增加新的产品，无能为力；支持增加产品族）  

 以上三种工厂 方法在等级结构和产品族这两个方向上的支持程度不同。所以要根据情况考虑应该使用哪种方法。

---END---

---

####参考文献

[1] http://laughingchs.iteye.com/blog/1169986